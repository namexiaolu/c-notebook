## 第三章 运算符和表达式

& 与  都为1才为1

^ 异或  不一样为1 ，一样就是0

| 或 有一个为1即为1

~ 取反 

sizeof 返回变量的类型所占的大小。 int 就是4 char就是1


``` c++
cout <<sizeof(char) << endl; _1__ 

cout << sizeof(short) << endl; __2_ 

cout << sizeof(int) << endl; __4_ 

cout << sizeof(float) << endl; _4__ 

cout << sizeof(double) << endl; __8_ 
```


逗号运算符，返回值是最后一个。

一般来说，-元运算符优先级高于对应的二元运算符;
弄不清楚优先级，就加括号;



### 补码

有没有一个方法可以用加法表示减法

- 注意:对有符号的数，尽可能不要使用右移运算，因为到底是逻辑右移

  还是算术右移取决于编译器!



## 第四章 容器

### off-bny-oneerror 差一错误

因为下表一般都比实际的个数少1，所以for循环中的写的一般都是<而不是<=

我们进行思考时有两个思考问题的原则:

1. 首先考虑最简单情况的特例，然后将结果外推;
2. 仔细计算边界;

### 序列性容器。（物理上的连续。可以把多个存储区合并成一个整体）

1. 数组
   1.  遍历高效 O1
   2. 结尾插入删除 O1
   3. 中间插入删除 On
   4. 查找一般为On
   5. 数组容量 sizeof(a)/sizeof(a[0])
2. vector
   1. 可以自动扩容
   2. capacity 查看当前的容量   size查看已经有了多少数字
   3. push_back() pop_back() 尾后插入/删除 insert(--vec.end(),4) erase（vec.end()-1） 中间插入/删除

3. 字符串
   1. 字符串是以空字符('\0')结束的 字符数组

### 关联性容器




# 五
内存分配
普通变量 是存放在  栈区    栈区是从高地址到低地址
指针变量  指针保存在栈区，
static int c =0 存在全局初始化区（静态区）
new() 堆区  低地址到高地址
函数             代码区





其他语言（java）当空间 有5块 但是中间一块被占用了  就不能分配4个空间大小的东西了。不够灵活。

RAII- 资源管理方案
依托于栈和析构函数来对资源进行管理


栈不要干太占内存的事，容易崩。

## 内存泄露
堆空间  程序未释放或者无法释放，造成系统内存浪费，。  导致程序运行慢，。甚至系统崩溃。
内存泄露主要发生着堆内存分配方式中。

## 智能指针和引用

auto_ptr  如果两个auto_ptr 指向同一个对象，第一个指针就会被销毁。很难受

unique_ptr 是专属所有权，只能被一个对象拥有。不支持复制和赋值。可以用move来转移指针。让别的uniqueptr指向当前对象 。

shared_ptr 通过引用计数共享同一个对象。当引用为0时，进行析构。

​	但是会出现互相引用的问题 ，导致内存无法回收，造成内存泄漏。

weak_ptr 弥补share_ptr的问题。只对shared_ptr进行引用，并不增加引用计数。当对应的shared_ptr销毁时，weak_ptr也被销毁。



## 多线程

ref 是引用

